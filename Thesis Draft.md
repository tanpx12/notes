
# Background_Concepts
## Blockchain

Blockchain is a decentralized and distributed digital ledger technology that records transactions across multiple computers or nodes. The con-cept of blockchain was first mentioned in 1991 as “a cryptographically secured chain of blocks”, but there's not much concern for it at that time. Not until 2008, when Satoshi Nakamoto introduced Bitcoin and its whitepaper named: "Bitcoin: A Peer-to-Peer Electronic Cash System", did blockchain started to be widely recognized. Since then, many other blockchains (Ethereum, Ripple, Polkadot,...) are introduced, helping to spread the concept of blockchain and encourage the research and development of this technology.

A blockchain is an ordered, append-only back-linked list of blocks. Each block consists of 2 parts: block header and transaction data. The block header contains the reference to the previous block and the compact information of the current block such as the timestamp it is created, the root of Merkle Tree which summarize transactions that block contains, ... . The transaction data part contains the list of transactions included in that block. Transactions represent the actions or exchanges of data or assets that are recorded on the blockchain. Each transaction contains relevant information, such as the sender's and recipient's addresses, the amount transferred, and other necessary data specific to the application of the blockchain.  

\\ Figure: simplify diagram of blockchain

This chain of data is stored simultaneously on multiple computer systems called "node" and kept synchronized by a consensus mechanism. They are algorithms or protocols that enable nodes to agree on the validity and order of transactions. The most well-known consensus mechanism is Proof of Work (PoW), which involves miners solving computationally intensive puzzles to validate transactions and add blocks to the blockchain. Other consensus mechanisms like Proof of Stake (PoS), Delegated Proof of Stake (DPoS), and Practical Byzantine Fault Tolerance (PBFT) are also used in different blockchain implementations. By combining these core components and mechanisms form the core natures of the blockchain: decentralization, security and immutability. 

Unlike traditional centralized systems, a blockchain operates in a decentralized manner. Instead of relying on a single central authority, multiple participants, often referred to as nodes or miners, maintain and validate the blockchain collectively. Each node has a copy of the entire blockchain, and they work together to achieve consensus on the state of the blockchain. Hence, ensure the decentralization of the blockchain.

Blockchain employs cryptographic techniques to ensure the security and immutability of the recorded data. Each transaction within a block is secured using cryptographic algorithms, making it extremely difficult for anyone to tamper with the data. Additionally, the decentralized nature of the blockchain makes it resilient to attacks, as manipulating the data would require controlling a majority of the network's computational power.

Since the blockchain is an append-only back-linked list, once a block is added to the blockchain, it becomes nearly impossible to modify or remove it. Changing the data in one block would require changing the subsequent blocks and the consensus of the entire network, which is computationally infeasible due to the decentralized nature of the blockchain. This immutability enhances trust and integrity in the system.

Blockchain implementations vary by application and requirements, generally divided into 2 category: public and private blockchain (permissionless and permissioned blockchain), which is based on their permission model in specifying block-producing nodes of the system. If anyone from public community can join in the production process of a new block, then it is called a public blockchain. Otherwise, if there is any form of authorization for publishing a new block to the chain, then it can be considered a private blockchain. 

Public blockchain are decentralized, meaning no single entity or authority has control over the network. The consensus mechanism ensures that decisions about the state of the blockchain are made collectively by the participants in a distributed manner. Meanwhile, private blockchains can vary in their level of decentralization. They are often more centralized compared to public blockchains since they are governed by a limited number of entities or consortium members. The control and decision-making power may be more concentrated, depending on the design and rules of the private blockchain. 

On the security and trust aspect, public blockchains rely on cryptographic algorithms and consensus mechanisms to ensure the security and trustworthiness of the network. The decentralized nature of public blockchains enhances security by making it difficult for malicious actors to tamper with the data. Private blockchains can also employ cryptographic techniques to secure the network. However, since access is restricted to known participants, the level of trust among the participants is typically higher compared to public blockchains. Private blockchains may be more susceptible to attacks or manipulation if the consensus or security mechanisms are controlled by a few entities.

In term of use cases, private blockchains find applications in industries or organizations that prioritize privacy, control, and compliance. They are used for supply chain management, interbank transactions, healthcare data management, and other scenarios where a restricted and known group of participants is involved. While public blockchains are well-suited for applications that require transparency, censorship resistance, and where permissionless participation is desired. They are commonly used for cryptocurrencies, decentralized applications (DApps), and token ecosystems. In this thesis, the proposed solutions's target is to deliver an easy to use tools for users to access and interact with the blockchain. Therefore, the public blockchain space where the accessibility is not limited, is best fit for this solution. 

At it's core, a public blockchain consists of multiple components that build up its characteristic such as: a peer-to-peer network of nodes with communication protocols, an opened and distributed ledger with transactions and balance records, cryptography techniques and a distributed consensus mechanism. To better understand the proposed solution in this thesis, the main concepts of these components will be introduced in the following sub-section: Asymmetric key cryptography, wallet and transactions.  

Asymmetric key cryptography also known as public key cryptography is a cryptographic system that utilizes a pair of mathematically related keys: a public key and a private key. Unlike symmetric cryptography, which uses a single shared key for both encryption and decryption, asymmetric cryptography provides separate keys for these operations. With a huge number of users and frequently interactions between anonymous users, using asymmetric key cryptography would be much better choice for the system instead of setting up a trusted channel for each interaction. It allows secure interactions between users that not knowing or trusting each other. Further more, the public blockchain utilizes Elliptic Curve Digital Signature Algorithm - ECDSA to levitate the security of the asymmetric key cryptography. Each account on the the blockchain possesses a pair of public and private keys. The private key is used to sign transactions for interactions with the blockchain, which is why it need to be kept secret for your custody of the account and associated assets, while the public key is used to derive into a unique address, the account's identity on the network, and the transactions validation process. 

A wallet is an interface for managing funds and accessibility of an account on public blockchain. This including storing and managing the private key correspond with the account, creating and signing transactions, ... Usually, a wallet will be created along side the seed of the private key and it can manage multiple private keys or accounts at the same time. In general, there are 2 types of wallets: hardware wallet and software wallet. Hardware wallets are physical devices designed specifically for secure cryptocurrency storage. They generate and store private keys offline, reducing the risk of exposure to online threats. Transactions are typically signed on the device itself, providing an extra layer of security. On the other hand, software wallets are software applications that can be installed on computers, smartphones, or other devices. They can be further categorized into desktop wallets (installed on a computer), mobile wallets (installed on a smartphone), and web wallets (accessible via a web browser). Due to its convenient, software are ways more popular and widely used than the hardware one. Therefore, the proposed solution is implemented as a software wallet. 

Transactions on a blockchain often refer to actions that change the current state of the blockchain. An user initiates a transaction by creating a request to transfer assets or data. This request typically includes  essential information such as the sender's address, the recipient's address, the amount or quantity being transferred, and any additional data specific to the blockchain application. Then, sender uses their private key to create a digital signature over the transaction data. This will guarantee that the transaction was authorized by the rightful owner. After that, the transaction is broadcasted to the blockchain network. Participating nodes receive the transaction and verify the validity of the transaction before propagate to its neighbors. Once the transaction is getting verified, it will be included in a mempool and ready to be included into a block. When the block is mined and finalized so as the transaction inside that block. One thing to notice is making transaction on public blockchain required fees, usually in the form of the native token of that blockchain. The fee amount is based on multiple factor such as the design of the blockchain, the computing power needed to execute the transaction, the traffic of the network, etc. 

## Smart Contracts

Smart contracts are self-executing agreements or program that run on a blockchain. They are coded with predefined rules and conditions, and their execution in automatically triggered when a certain conditions are met. Although the concept of "smart contract" have been around for quiet a while, but not until Ethereum, a public blockchain with a quasi-Turing-complete state machine, was released did smart contract starting to gain popularity among developer and researcher. Since then, the term "smart contract" has been widely known as a computer program deployed and runs on blockchain. Smart contracts are executed and validated by the participants of the blockchain network. Once deployed on the blockchain, they become part of the distributed ledger and are replicated across all participating nodes. This ensures transparency and prevent any individual or organization from having control or ability to manipulate the contract's execution. When predefined conditions are met, smart contracts automatically execute the specified actions without the need for human intervention. A blockchain should have a virtual machine to to be able to execute smart contract code. Some of the well-known virutal machine could be: Ethereum Virtual Machine (EVM), Filecoin Virtual Machine (FVM), ParaState SSVM, ... Within the scope of this thesis, "smart contract" only refer to the one on an EVM-compatible public blockchain, written in Solidity programming language.  

The EVM is the part of Ethereum that handles smart contract deployment and execution. Simple value transfer transactions from one EOA to another don’t need to involve it, practically speaking, but everything else will involve a state update computed by the EVM. At a high level, the EVM running on the Ethereum blockchain can be thought of as a global decentralized computer containing millions of executable objects, each with its own permanent data store.

The EVM is a quasi–Turing-complete state machine; "quasi" because all execution processes are limited to a finite number of computational steps by the amount of gas available for any given smart contract execution. As such, the halting problem is "solved" (all program executions will halt) and the situation where execution might (accidentally or maliciously) run forever, thus bringing the Ethereum platform to halt in its entirety, is avoided. [2][https://github.com/ethereumbook/ethereumbook/blob/develop/13evm.asciidoc#what-is-the-evm] 

The EVM employs a stack-based architecture, where all in-memory values are stored on a stack, utilizing a word size of 256 bits primarily for efficient native hashing and elliptic curve operations. It consists of several addressable data components, including a read-only program code ROM that holds the bytecode of the smart contract to be executed, a volatile memory with explicitly initialized zero values for each location, and a permanent storage component integrated into the Ethereum state, which is also zero-initialized and retains data across multiple contract executions. While the bytecode remains immutable after contract deployed, the storage can be changed with contract interaction call. These calls cost fee to execute, which depends on the complexity and the amount of state change in the storage of the call. The immutability of the bytecode provides security and trust to users of the Ethereum network, as they can verify that the deployed smart contract's code has not been tampered with or altered since its deployment. It also ensures that the execution of the smart contract follows the original intentions and rules defined in its initial deployment. 

## Account Abstraction

Account abstraction refers to a concept in blockchain technology where the traditional account model is abstracted or generalized to allow more flexible and advanced functionalities. Account abstraction was first mentioned in the context of blockchain technology in the Ethereum Improvement Proposal (EIP) 86. The proposal outlined the concept of account abstraction and its potential benefits for the Ethereum platform. EIP 86 introduced the idea of abstracting the account model to allow smart contracts to have their own internal state and balance.

In a blockchain network, account are typically associated with address and hold balances of the native cryptocurrency. There are typically 2 types of account: External Owned Accounts (EOAs) and  smart contracts. 
EOAs are accounts generated using wallet software and managed by a cryptographic pair of public and private key. An EOA can be used actively, meaning that it can initiate transactions and pay gas fee for transaction execution. However, it is limited to execute basic operation like sending assets or interact with smart contracts. Also, EOAs have limited verification logic since the only way to verify a transaction is by ECDSA signature. Unlike EOAs, which are controlled by private key, smart contract accounts are controlled by the code of the deployed smart contract itself. It enable the execution of self-enforcing and autonomous programs on the blockchain. One thing to notice is smart contract accounts are "passive" meaning it can only create transactions in response to an external call from an EOA and cannot pay gas fee directly. However, smart contract accounts are programmable so it could execute arbitrary logic depending on what we program it in the first place. 

![[Pasted image 20230626154518.png]]

Account abstraction allows developers to design and implement smart contracts that can directly control and manage their own accounts. This means that smart contracts can have their own state, balance, and logic, similar to EOAs in the network. They can receive and hold funds, initiate transactions, and interact with other contracts autonomously.

By abstracting the account model, blockchain platforms enable more complex and powerful smart contract capabilities. It provides a higher level of programmability and allows for more intricate interactions and functionalities within the blockchain ecosystem. Account abstraction is a fundamental component in platforms like Ethereum, enabling the execution of decentralized applications (dApps) and the implementation of advanced contract-based systems, such as decentralized finance (DeFi) protocols.

Overall, account abstraction empowers smart contracts by expanding their capabilities to include account-like features, enabling them to act as autonomous entities within the blockchain network.

## Social Recovery

As we all know, wallet are control by a pair of cryptographic keys generated by a 12-words secret phrase called mnemonic. Although this 12-words secret phrase is readable, it is really hard for a normal user to remember and most of the time, they forgot the phrase. An alternative is users could write out the phrase on paper or store it somewhere in their device. This is good for protecting against loss, but they do nothing against theft. If you lose your device or accidentally expose the paper that you write your mnemonic to then your fund is possiblely at risk. Understanding the nessesary of method that can protect against both loss and theft, social recovery is introduced. 

Social recovery is a method of account recovery that relies on social connections and trusted individuals to regain access to a user's account or assets in case of lost keys, forgotten passwords or other access issues. It leverages the concept of decentralized trust to provide an alternative approach to traditional account recovery processes. 

A social recovery process often involved 2 main actors: the owner and the guardians. The owner is the one who owns the secret and want to recover after somehow losing it. The guardians is a group of trusted factors and are appointed by the owner. Once the owner lose his secret, he could contact to the guardians to ask them to recover the secret. It would require a certain number of guardians combine with each other to be able to recover the secret. This is feasible by using cryptographic scheme like signature threshold or shamir secret sharing to enforce the requirements when set up the guardians, hence, strengthen the security of the secret. 

An popular example of social recovery is the multisig wallet. In a multisig wallet, a predetermined number of keys or signatures are required to sign off on a transaction before it can be executed on the blockchain. These keys are typically held by different individuals or entities involved in the wallet setup. For example, let's say a multisig wallet is set up with a 2-of-3 configuration. This means that there are three keys, and any two out of the three keys are required to authorize a transaction. These keys can be distributed among different people or held by separate devices, adding redundancy and reducing the risk of a single point of failure. 

Overall, social recovery is an important feature that plays a pivotal role in leveraging both user experience and security within the blockchain wallet ecosystem. By incorporating social recovery mechanisms, blockchain wallets can provide a robust and user-friendly solution for account access restoration and key management. The ability to involve trusted individuals or entities as recovery partners enhances the security of the wallet by reducing the risk of single-point failures associated with relying solely on private keys. Simultaneously, social recovery mechanisms offer convenience and peace of mind to users who may encounter challenges such as lost private keys or authentication issues. By striking a balance between security and usability, social recovery empowers users with control over their accounts and assets while mitigating the risks and complexities often associated with the management of cryptographic keys. Ultimately, the integration of social recovery into blockchain wallets contributes to a more accessible, reliable, and user-centric experience for individuals and organizations participating in the blockchain ecosystem.

# System requirement
## Existing solution

Account abstraction is a proposal to increase flexibility in the management and behavior of Ethereum accounts. The components of an account abstraction system including: wallet client, user operation bundler, onchain entry point, wallet factory smart contracts and paymaster smart contract (optional). The system itself is really sophisticated, so most of existing solutions often included some components instead of the whole system. This will create a diversity of solutions for user to pick from. Since the development team only focus on one or two components of the system, the quality of the delivered solution often meet the demand of the users. Some notable project could be Biconomy SDK and Safe wallet.

The Biconomy SDK is an open-sourced library for account abstraction integration. It provides solutions from onboarding to user engagement for a decentralized application (dApp) in a non-custodial way. It is a one-stop solution to enable an effortless experience in your dApp as it eases onboarding for new users and abstracts away transaction complexities that your users face on a daily basis. This is enabled using Smart Contract Wallets (SCW) built on top of our multi-chain Relayer Infrastructure. Although Biconomy SDK covers up most of the components in the system, it still hasn't unlocked the full potential of the account abstraction model like social recovery and flexible verification logic. Another thing to mention is the Biconomy SDK is just a library and still required specialized developers to be able to build and integrate it into a wallet. 

Safe Wallet (previous Gnosis Safe) is a multi-sig wallet, which means it will require multiple signatures to approve a transaction. It've been implementing account abstraction recently and provided a list of comprehensive features designed to enhance security, functionality, and convenience. With Safe Wallet, users can benefit from the following capabilities: multisig support - requiring multiple signing accounts to approve transactions before execution; spending policies to control the withdrawal amounts for each signing account; scheduled transactions for automated execution based on specified schedules; recovery mechanisms to regain access in case of primary key loss; gas abstraction enabling payment of transaction fees using ERC-20 tokens, etc. With a handful of features, Safe Wallet offers users a robust and secure platform for managing their cryptocurrency assets. But there're still room for implementation for Safe. The limitation in recovery options and signature scheme make it can not take full advantage of account abstraction model. Also, Safe Wallet still require an external wallet in order to create an account, making the account abstraction purpose less meaningful.

## Purpose

The main purpose of ChainGuard is to provide an account abstraction wallet for managing digital assets and self-sovereign identities with enhanced security feature and user friendly UX. Users can create transaction with seamless experience, from paying gas with stable coins to batching multiple transactions. 


## Actors

## Business Processes

## Non-functional requirements

# System design

# Implementation

# Conclusion


  